{"version":3,"file":"seemly-B1UhY21x.js","sources":["../../node_modules/seemly/es/animation/next-frame-once.js","../../node_modules/seemly/es/dom/happens-in.js","../../node_modules/seemly/es/dom/get-precise-event-target.js","../../node_modules/seemly/es/css/responsive.js","../../node_modules/seemly/es/css/index.js","../../node_modules/seemly/es/color/colors.js","../../node_modules/seemly/es/color/index.js","../../node_modules/seemly/es/misc/index.js"],"sourcesContent":["let onceCbs = [];\nconst paramsMap = new WeakMap();\nfunction flushOnceCallbacks() {\n    onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));\n    onceCbs = [];\n}\nfunction beforeNextFrameOnce(cb, ...params) {\n    paramsMap.set(cb, params);\n    if (onceCbs.includes(cb))\n        return;\n    onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);\n}\nexport { beforeNextFrameOnce };\n","export function happensIn(e, dataSetPropName) {\n    let { target } = e;\n    while (target) {\n        if (target.dataset) {\n            if (target.dataset[dataSetPropName] !== undefined)\n                return true;\n        }\n        target = target.parentElement;\n    }\n    return false;\n}\n","export function getPreciseEventTarget(event) {\n    return event.composedPath()[0] || null;\n}\n","export function parseResponsiveProp(reponsiveProp) {\n    if (typeof reponsiveProp === \"number\") {\n        return {\n            '': reponsiveProp.toString()\n        };\n    }\n    const params = {};\n    reponsiveProp.split(/ +/).forEach((pairLiteral) => {\n        if (pairLiteral === '')\n            return;\n        const [prefix, value] = pairLiteral.split(':');\n        if (value === undefined) {\n            params[''] = prefix;\n        }\n        else {\n            params[prefix] = value;\n        }\n    });\n    return params;\n}\nfunction parseResponsivePropValue(reponsiveProp, activeKeyOrSize) {\n    var _a;\n    if (reponsiveProp === undefined || reponsiveProp === null)\n        return undefined;\n    const classObj = parseResponsiveProp(reponsiveProp);\n    if (activeKeyOrSize === undefined)\n        return classObj[''];\n    if (typeof activeKeyOrSize === 'string') {\n        return (_a = classObj[activeKeyOrSize]) !== null && _a !== void 0 ? _a : classObj[''];\n    }\n    else if (Array.isArray(activeKeyOrSize)) {\n        for (let i = activeKeyOrSize.length - 1; i >= 0; --i) {\n            const key = activeKeyOrSize[i];\n            if (key in classObj)\n                return classObj[key];\n        }\n        return classObj[''];\n    }\n    else {\n        // Here we suppose all the keys are number formatted\n        let activeValue = undefined;\n        let activeKey = -1;\n        Object.keys(classObj).forEach((key) => {\n            const keyAsNum = Number(key);\n            if (!Number.isNaN(keyAsNum) &&\n                activeKeyOrSize >= keyAsNum &&\n                keyAsNum >= activeKey) {\n                activeKey = keyAsNum;\n                activeValue = classObj[key];\n            }\n        });\n        return activeValue;\n    }\n}\nexport { parseResponsivePropValue };\n","export function depx(value) {\n    if (typeof value === 'string') {\n        if (value.endsWith('px')) {\n            return Number(value.slice(0, value.length - 2));\n        }\n        return Number(value);\n    }\n    return value;\n}\nfunction pxfy(value) {\n    if (value === undefined || value === null)\n        return undefined;\n    if (typeof value === 'number')\n        return `${value}px`;\n    if (value.endsWith('px'))\n        return value;\n    return `${value}px`;\n}\nexport { pxfy };\nfunction getMargin(value, position) {\n    const parts = value.trim().split(/\\s+/g);\n    const margin = {\n        top: parts[0]\n    };\n    switch (parts.length) {\n        case 1:\n            margin.right = parts[0];\n            margin.bottom = parts[0];\n            margin.left = parts[0];\n            break;\n        case 2:\n            margin.right = parts[1];\n            margin.left = parts[1];\n            margin.bottom = parts[0];\n            break;\n        case 3:\n            margin.right = parts[1];\n            margin.bottom = parts[2];\n            margin.left = parts[1];\n            break;\n        case 4:\n            margin.right = parts[1];\n            margin.bottom = parts[2];\n            margin.left = parts[3];\n            break;\n        default:\n            throw new Error('[seemly/getMargin]:' + value + ' is not a valid value.');\n    }\n    if (position === undefined)\n        return margin;\n    return margin[position];\n}\nfunction getGap(value, orient) {\n    const [rowGap, colGap] = value.split(' ');\n    if (!orient)\n        return {\n            row: rowGap,\n            col: colGap || rowGap\n        };\n    return orient === 'row' ? rowGap : colGap;\n}\nexport { getMargin, getMargin as getPadding, getGap };\nexport { parseResponsiveProp, parseResponsivePropValue } from './responsive';\n","export default {\n    black: '#000',\n    silver: '#C0C0C0',\n    gray: '#808080',\n    white: '#FFF',\n    maroon: '#800000',\n    red: '#F00',\n    purple: '#800080',\n    fuchsia: '#F0F',\n    green: '#008000',\n    lime: '#0F0',\n    olive: '#808000',\n    yellow: '#FF0',\n    navy: '#000080',\n    blue: '#00F',\n    teal: '#008080',\n    aqua: '#0FF',\n    transparent: '#0000'\n};\n","import colors from './colors';\nconst prefix = '^\\\\s*';\nconst suffix = '\\\\s*$';\nconst percent = '\\\\s*((\\\\.\\\\d+)|(\\\\d+(\\\\.\\\\d*)?))%\\\\s*'; // 4 offset\nconst float = '\\\\s*((\\\\.\\\\d+)|(\\\\d+(\\\\.\\\\d*)?))\\\\s*'; // 4 offset\nconst hex = '([0-9A-Fa-f])';\nconst dhex = '([0-9A-Fa-f]{2})';\nconst hslRegex = new RegExp(`${prefix}hsl\\\\s*\\\\(${float},${percent},${percent}\\\\)${suffix}`);\nconst hsvRegex = new RegExp(`${prefix}hsv\\\\s*\\\\(${float},${percent},${percent}\\\\)${suffix}`);\nconst hslaRegex = new RegExp(`${prefix}hsla\\\\s*\\\\(${float},${percent},${percent},${float}\\\\)${suffix}`);\nconst hsvaRegex = new RegExp(`${prefix}hsva\\\\s*\\\\(${float},${percent},${percent},${float}\\\\)${suffix}`);\nconst rgbRegex = new RegExp(`${prefix}rgb\\\\s*\\\\(${float},${float},${float}\\\\)${suffix}`);\nconst rgbaRegex = new RegExp(`${prefix}rgba\\\\s*\\\\(${float},${float},${float},${float}\\\\)${suffix}`);\nconst sHexRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${suffix}`);\nconst hexRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${suffix}`);\nconst sHexaRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${hex}${suffix}`);\nconst hexaRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${dhex}${suffix}`);\nfunction parseHex(value) {\n    return parseInt(value, 16);\n}\n/**\n * Convert color string to hsla array\n * @param color format like hsl(180, 100%, 100%), hsla(180, 100%, 100%, 1)\n * @returns\n */\nexport function hsla(color) {\n    try {\n        let i;\n        if ((i = hslaRegex.exec(color))) {\n            return [\n                roundDeg(i[1]),\n                roundPercent(i[5]),\n                roundPercent(i[9]),\n                roundAlpha(i[13])\n            ];\n        }\n        else if ((i = hslRegex.exec(color))) {\n            return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];\n        }\n        throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);\n    }\n    catch (e) {\n        throw e;\n    }\n}\n/**\n * Convert color string to hsva array\n * @param color format like hsv(180, 100%, 100%), hsva(180, 100%, 100%, 1)\n * @returns\n */\nexport function hsva(color) {\n    try {\n        let i;\n        if ((i = hsvaRegex.exec(color))) {\n            return [\n                roundDeg(i[1]),\n                roundPercent(i[5]),\n                roundPercent(i[9]),\n                roundAlpha(i[13])\n            ];\n        }\n        else if ((i = hsvRegex.exec(color))) {\n            return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];\n        }\n        throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);\n    }\n    catch (e) {\n        throw e;\n    }\n}\n/**\n * Convert color string to rgba array.\n * @param color format like #000[0], #000000[00], rgb(0, 0, 0), rgba(0, 0, 0, 0) and basic color keywords https://www.w3.org/TR/css-color-3/#html4 and transparent\n * @returns\n */\nexport function rgba(color) {\n    try {\n        let i;\n        if ((i = hexRegex.exec(color))) {\n            return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];\n        }\n        else if ((i = rgbRegex.exec(color))) {\n            return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];\n        }\n        else if ((i = rgbaRegex.exec(color))) {\n            return [\n                roundChannel(i[1]),\n                roundChannel(i[5]),\n                roundChannel(i[9]),\n                roundAlpha(i[13])\n            ];\n        }\n        else if ((i = sHexRegex.exec(color))) {\n            return [\n                parseHex(i[1] + i[1]),\n                parseHex(i[2] + i[2]),\n                parseHex(i[3] + i[3]),\n                1\n            ];\n        }\n        else if ((i = hexaRegex.exec(color))) {\n            return [\n                parseHex(i[1]),\n                parseHex(i[2]),\n                parseHex(i[3]),\n                roundAlpha(parseHex(i[4]) / 255)\n            ];\n        }\n        else if ((i = sHexaRegex.exec(color))) {\n            return [\n                parseHex(i[1] + i[1]),\n                parseHex(i[2] + i[2]),\n                parseHex(i[3] + i[3]),\n                roundAlpha(parseHex(i[4] + i[4]) / 255)\n            ];\n        }\n        else if (color in colors) {\n            return rgba(colors[color]);\n        }\n        throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);\n    }\n    catch (e) {\n        throw e;\n    }\n}\nfunction normalizeAlpha(alphaValue) {\n    return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;\n}\nfunction stringifyRgb(r, g, b) {\n    return `rgb(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)})`;\n}\nfunction stringifyRgba(r, g, b, a) {\n    return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha(a)})`;\n}\nfunction compositeChannel(v1, a1, v2, a2, a) {\n    return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a);\n}\nexport function composite(background, overlay) {\n    if (!Array.isArray(background))\n        background = rgba(background);\n    if (!Array.isArray(overlay))\n        overlay = rgba(overlay);\n    const a1 = background[3];\n    const a2 = overlay[3];\n    const alpha = roundAlpha(a1 + a2 - a1 * a2);\n    return stringifyRgba(compositeChannel(background[0], a1, overlay[0], a2, alpha), compositeChannel(background[1], a1, overlay[1], a2, alpha), compositeChannel(background[2], a1, overlay[2], a2, alpha), alpha);\n}\nexport function changeColor(base, options) {\n    const [r, g, b, a = 1] = Array.isArray(base) ? base : rgba(base);\n    if (options.alpha) {\n        return stringifyRgba(r, g, b, options.alpha);\n    }\n    return stringifyRgba(r, g, b, a);\n}\nexport function scaleColor(base, options) {\n    const [r, g, b, a = 1] = Array.isArray(base) ? base : rgba(base);\n    const { lightness = 1, alpha = 1 } = options;\n    return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);\n}\nexport function getAlpha(base) {\n    var _a;\n    const alpha = (_a = (Array.isArray(base) ? base : rgba(base))[3]) !== null && _a !== void 0 ? _a : 1;\n    return alpha;\n}\nexport function getAlphaString(base) {\n    return `${getAlpha(base)}`;\n}\nexport function roundAlpha(value) {\n    const v = Math.round(Number(value) * 100) / 100;\n    if (v > 1)\n        return 1;\n    if (v < 0)\n        return 0;\n    return v;\n}\nexport function roundDeg(value) {\n    const v = Math.round(Number(value));\n    if (v >= 360)\n        return 0;\n    if (v < 0)\n        return 0;\n    return v;\n}\nexport function roundChannel(value) {\n    const v = Math.round(Number(value));\n    if (v > 255)\n        return 255;\n    if (v < 0)\n        return 0;\n    return v;\n}\nexport function roundPercent(value) {\n    const v = Math.round(Number(value));\n    if (v > 100)\n        return 100;\n    if (v < 0)\n        return 0;\n    return v;\n}\nexport function toRgbString(base) {\n    const [r, g, b] = Array.isArray(base) ? base : rgba(base);\n    return stringifyRgb(r, g, b);\n}\nexport function toRgbaString(base) {\n    const [r, g, b] = base;\n    if (3 in base) {\n        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base[3])})`;\n    }\n    return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;\n}\nexport function toHsvString(base) {\n    return `hsv(${roundDeg(base[0])}, ${roundPercent(base[1])}%, ${roundPercent(base[2])}%)`;\n}\nexport function toHsvaString(base) {\n    const [h, s, v] = base;\n    if (3 in base) {\n        return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, ${roundAlpha(base[3])})`;\n    }\n    return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, 1)`;\n}\nexport function toHslString(base) {\n    return `hsl(${roundDeg(base[0])}, ${roundPercent(base[1])}%, ${roundPercent(base[2])}%)`;\n}\nexport function toHslaString(base) {\n    const [h, s, l] = base;\n    if (3 in base) {\n        return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, ${roundAlpha(base[3])})`;\n    }\n    return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, 1)`;\n}\n/**\n *\n * @param base [255, 255, 255, 255], [255, 255, 255], any hex string\n * @returns\n */\nexport function toHexaString(base) {\n    if (typeof base === 'string') {\n        let i;\n        if (i = hexRegex.exec(base)) {\n            return `${i[0]}FF`;\n        }\n        else if (i = hexaRegex.exec(base)) {\n            return i[0];\n        }\n        else if (i = sHexRegex.exec(base)) {\n            return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}FF`;\n        }\n        else if (i = sHexaRegex.exec(base)) {\n            return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}${i[4]}${i[4]}`;\n        }\n        throw new Error(`[seemly/toHexString]: Invalid hex value ${base}.`);\n    }\n    const hex = `#${base\n        .slice(0, 3)\n        .map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, '0'))\n        .join('')}`;\n    const a = base.length === 3\n        ? 'FF'\n        : roundChannel(base[3] * 255)\n            .toString(16)\n            .padStart(2, '0')\n            .toUpperCase();\n    return hex + a;\n}\n/**\n *\n * @param base [255, 255, 255, 255], [255, 255, 255], any hex string\n * @returns\n */\nexport function toHexString(base) {\n    if (typeof base === 'string') {\n        let i;\n        if (i = hexRegex.exec(base)) {\n            return i[0];\n        }\n        else if (i = hexaRegex.exec(base)) {\n            return i[0].slice(0, 7);\n        }\n        else if (i = (sHexRegex.exec(base) || sHexaRegex.exec(base))) {\n            return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}`;\n        }\n        throw new Error(`[seemly/toHexString]: Invalid hex value ${base}.`);\n    }\n    return `#${base\n        .slice(0, 3)\n        .map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, '0'))\n        .join('')}`;\n}\nexport { hsl2hsv, hsv2hsl, hsv2rgb, rgb2hsv, rgb2hsl, hsl2rgb } from './convert';\n","export function createId(length = 8) {\n    return Math.random()\n        .toString(16)\n        .slice(2, 2 + length);\n}\nexport function repeat(count, v) {\n    const ret = [];\n    for (let i = 0; i < count; ++i) {\n        ret.push(v);\n    }\n    return ret;\n}\nfunction indexMap(count, createValue) {\n    const ret = [];\n    if (!createValue) {\n        for (let i = 0; i < count; ++i) {\n            ret.push(i);\n        }\n        return ret;\n    }\n    for (let i = 0; i < count; ++i) {\n        ret.push(createValue(i));\n    }\n    return ret;\n}\nexport { indexMap };\nexport async function sleep(ms) {\n    return new Promise(resolve => {\n        setTimeout(resolve, ms);\n    });\n}\n"],"names":["onceCbs","paramsMap","flushOnceCallbacks","cb","beforeNextFrameOnce","params","happensIn","e","dataSetPropName","target","getPreciseEventTarget","event","parseResponsiveProp","reponsiveProp","pairLiteral","prefix","value","parseResponsivePropValue","activeKeyOrSize","_a","classObj","i","key","activeValue","activeKey","keyAsNum","depx","pxfy","getMargin","position","parts","margin","getGap","orient","rowGap","colGap","colors","suffix","float","hex","dhex","rgbRegex","rgbaRegex","sHexRegex","hexRegex","sHexaRegex","hexaRegex","parseHex","rgba","color","roundChannel","roundAlpha","normalizeAlpha","alphaValue","stringifyRgba","r","g","b","a","compositeChannel","v1","a1","v2","a2","composite","background","overlay","alpha","changeColor","base","options","scaleColor","lightness","toRgbaString","v","createId","length"],"mappings":"AAAA,IAAIA,EAAU,CAAA,EACd,MAAMC,EAAY,IAAI,QACtB,SAASC,GAAqB,CAC1BF,EAAQ,QAASG,GAAOA,EAAG,GAAGF,EAAU,IAAIE,CAAE,CAAC,CAAC,EAChDH,EAAU,CAAA,CACd,CACA,SAASI,EAAoBD,KAAOE,EAAQ,CACxCJ,EAAU,IAAIE,EAAIE,CAAM,EACpB,CAAAL,EAAQ,SAASG,CAAE,GAEvBH,EAAQ,KAAKG,CAAE,IAAM,GAAK,sBAAsBD,CAAkB,CACtE,CCXO,SAASI,EAAUC,EAAGC,EAAiB,CAC1C,GAAI,CAAE,OAAAC,CAAQ,EAAGF,EACjB,KAAOE,GAAQ,CACX,GAAIA,EAAO,SACHA,EAAO,QAAQD,CAAe,IAAM,OACpC,MAAO,GAEfC,EAASA,EAAO,aACnB,CACD,MAAO,EACX,CCVO,SAASC,EAAsBC,EAAO,CACzC,OAAOA,EAAM,aAAY,EAAG,CAAC,GAAK,IACtC,CCFO,SAASC,EAAoBC,EAAe,CAC/C,GAAI,OAAOA,GAAkB,SACzB,MAAO,CACH,GAAIA,EAAc,SAAU,CACxC,EAEI,MAAMR,EAAS,CAAA,EACf,OAAAQ,EAAc,MAAM,IAAI,EAAE,QAASC,GAAgB,CAC/C,GAAIA,IAAgB,GAChB,OACJ,KAAM,CAACC,EAAQC,CAAK,EAAIF,EAAY,MAAM,GAAG,EACzCE,IAAU,OACVX,EAAO,EAAE,EAAIU,EAGbV,EAAOU,CAAM,EAAIC,CAE7B,CAAK,EACMX,CACX,CACA,SAASY,EAAyBJ,EAAeK,EAAiB,CAC9D,IAAIC,EACJ,GAAmCN,GAAkB,KACjD,OACJ,MAAMO,EAAWR,EAAoBC,CAAa,EAClD,GAAIK,IAAoB,OACpB,OAAOE,EAAS,EAAE,EACtB,GAAI,OAAOF,GAAoB,SAC3B,OAAQC,EAAKC,EAASF,CAAe,KAAO,MAAQC,IAAO,OAASA,EAAKC,EAAS,EAAE,EAEnF,GAAI,MAAM,QAAQF,CAAe,EAAG,CACrC,QAASG,EAAIH,EAAgB,OAAS,EAAGG,GAAK,EAAG,EAAEA,EAAG,CAClD,MAAMC,EAAMJ,EAAgBG,CAAC,EAC7B,GAAIC,KAAOF,EACP,OAAOA,EAASE,CAAG,CAC1B,CACD,OAAOF,EAAS,EAAE,CACrB,KACI,CAED,IAAIG,EACAC,EAAY,GAChB,cAAO,KAAKJ,CAAQ,EAAE,QAASE,GAAQ,CACnC,MAAMG,EAAW,OAAOH,CAAG,EACvB,CAAC,OAAO,MAAMG,CAAQ,GACtBP,GAAmBO,GACnBA,GAAYD,IACZA,EAAYC,EACZF,EAAcH,EAASE,CAAG,EAE1C,CAAS,EACMC,CACV,CACL,CCrDO,SAASG,EAAKV,EAAO,CACxB,OAAI,OAAOA,GAAU,SACbA,EAAM,SAAS,IAAI,EACZ,OAAOA,EAAM,MAAM,EAAGA,EAAM,OAAS,CAAC,CAAC,EAE3C,OAAOA,CAAK,EAEhBA,CACX,CACA,SAASW,EAAKX,EAAO,CACjB,GAA2BA,GAAU,KAErC,OAAI,OAAOA,GAAU,SACV,GAAGA,CAAK,KACfA,EAAM,SAAS,IAAI,EACZA,EACJ,GAAGA,CAAK,IACnB,CAEA,SAASY,EAAUZ,EAAOa,EAAU,CAChC,MAAMC,EAAQd,EAAM,KAAM,EAAC,MAAM,MAAM,EACjCe,EAAS,CACX,IAAKD,EAAM,CAAC,CACpB,EACI,OAAQA,EAAM,OAAM,CAChB,IAAK,GACDC,EAAO,MAAQD,EAAM,CAAC,EACtBC,EAAO,OAASD,EAAM,CAAC,EACvBC,EAAO,KAAOD,EAAM,CAAC,EACrB,MACJ,IAAK,GACDC,EAAO,MAAQD,EAAM,CAAC,EACtBC,EAAO,KAAOD,EAAM,CAAC,EACrBC,EAAO,OAASD,EAAM,CAAC,EACvB,MACJ,IAAK,GACDC,EAAO,MAAQD,EAAM,CAAC,EACtBC,EAAO,OAASD,EAAM,CAAC,EACvBC,EAAO,KAAOD,EAAM,CAAC,EACrB,MACJ,IAAK,GACDC,EAAO,MAAQD,EAAM,CAAC,EACtBC,EAAO,OAASD,EAAM,CAAC,EACvBC,EAAO,KAAOD,EAAM,CAAC,EACrB,MACJ,QACI,MAAM,IAAI,MAAM,sBAAwBd,EAAQ,wBAAwB,CAC/E,CACD,OAAIa,IAAa,OACNE,EACJA,EAAOF,CAAQ,CAC1B,CACA,SAASG,EAAOhB,EAAOiB,EAAQ,CAC3B,KAAM,CAACC,EAAQC,CAAM,EAAInB,EAAM,MAAM,GAAG,EACxC,OAAKiB,EAKEA,IAAW,MAAQC,EAASC,EAJxB,CACH,IAAKD,EACL,IAAKC,GAAUD,CAC3B,CAEA,CC5DA,MAAeE,EAAA,CACX,MAAO,OACP,OAAQ,UACR,KAAM,UACN,MAAO,OACP,OAAQ,UACR,IAAK,OACL,OAAQ,UACR,QAAS,OACT,MAAO,UACP,KAAM,OACN,MAAO,UACP,OAAQ,OACR,KAAM,UACN,KAAM,OACN,KAAM,UACN,KAAM,OACN,YAAa,OACjB,ECjBMrB,EAAS,QACTsB,EAAS,QAETC,EAAQ,uCACRC,EAAM,gBACNC,EAAO,mBAKPC,EAAW,IAAI,OAAO,GAAG1B,CAAM,aAAauB,CAAK,IAAIA,CAAK,IAAIA,CAAK,MAAMD,CAAM,EAAE,EACjFK,EAAY,IAAI,OAAO,GAAG3B,CAAM,cAAcuB,CAAK,IAAIA,CAAK,IAAIA,CAAK,IAAIA,CAAK,MAAMD,CAAM,EAAE,EAC5FM,EAAY,IAAI,OAAO,GAAG5B,CAAM,IAAIwB,CAAG,GAAGA,CAAG,GAAGA,CAAG,GAAGF,CAAM,EAAE,EAC9DO,EAAW,IAAI,OAAO,GAAG7B,CAAM,IAAIyB,CAAI,GAAGA,CAAI,GAAGA,CAAI,GAAGH,CAAM,EAAE,EAChEQ,EAAa,IAAI,OAAO,GAAG9B,CAAM,IAAIwB,CAAG,GAAGA,CAAG,GAAGA,CAAG,GAAGA,CAAG,GAAGF,CAAM,EAAE,EACrES,EAAY,IAAI,OAAO,GAAG/B,CAAM,IAAIyB,CAAI,GAAGA,CAAI,GAAGA,CAAI,GAAGA,CAAI,GAAGH,CAAM,EAAE,EAC9E,SAASU,EAAS/B,EAAO,CACrB,OAAO,SAASA,EAAO,EAAE,CAC7B,CAwDO,SAASgC,EAAKC,EAAO,CACxB,GAAI,CACA,IAAI5B,EACJ,GAAKA,EAAIuB,EAAS,KAAKK,CAAK,EACxB,MAAO,CAACF,EAAS1B,EAAE,CAAC,CAAC,EAAG0B,EAAS1B,EAAE,CAAC,CAAC,EAAG0B,EAAS1B,EAAE,CAAC,CAAC,EAAG,CAAC,EAExD,GAAKA,EAAIoB,EAAS,KAAKQ,CAAK,EAC7B,MAAO,CAACC,EAAa7B,EAAE,CAAC,CAAC,EAAG6B,EAAa7B,EAAE,CAAC,CAAC,EAAG6B,EAAa7B,EAAE,CAAC,CAAC,EAAG,CAAC,EAEpE,GAAKA,EAAIqB,EAAU,KAAKO,CAAK,EAC9B,MAAO,CACHC,EAAa7B,EAAE,CAAC,CAAC,EACjB6B,EAAa7B,EAAE,CAAC,CAAC,EACjB6B,EAAa7B,EAAE,CAAC,CAAC,EACjB8B,EAAW9B,EAAE,EAAE,CAAC,CAChC,EAEa,GAAKA,EAAIsB,EAAU,KAAKM,CAAK,EAC9B,MAAO,CACHF,EAAS1B,EAAE,CAAC,EAAIA,EAAE,CAAC,CAAC,EACpB0B,EAAS1B,EAAE,CAAC,EAAIA,EAAE,CAAC,CAAC,EACpB0B,EAAS1B,EAAE,CAAC,EAAIA,EAAE,CAAC,CAAC,EACpB,CAChB,EAEa,GAAKA,EAAIyB,EAAU,KAAKG,CAAK,EAC9B,MAAO,CACHF,EAAS1B,EAAE,CAAC,CAAC,EACb0B,EAAS1B,EAAE,CAAC,CAAC,EACb0B,EAAS1B,EAAE,CAAC,CAAC,EACb8B,EAAWJ,EAAS1B,EAAE,CAAC,CAAC,EAAI,GAAG,CAC/C,EAEa,GAAKA,EAAIwB,EAAW,KAAKI,CAAK,EAC/B,MAAO,CACHF,EAAS1B,EAAE,CAAC,EAAIA,EAAE,CAAC,CAAC,EACpB0B,EAAS1B,EAAE,CAAC,EAAIA,EAAE,CAAC,CAAC,EACpB0B,EAAS1B,EAAE,CAAC,EAAIA,EAAE,CAAC,CAAC,EACpB8B,EAAWJ,EAAS1B,EAAE,CAAC,EAAIA,EAAE,CAAC,CAAC,EAAI,GAAG,CACtD,EAEa,GAAI4B,KAASb,EACd,OAAOY,EAAKZ,EAAOa,CAAK,CAAC,EAE7B,MAAM,IAAI,MAAM,sCAAsCA,CAAK,GAAG,CACjE,OACM,EAAG,CACN,MAAM,CACT,CACL,CACA,SAASG,EAAeC,EAAY,CAChC,OAAOA,EAAa,EAAI,EAAIA,EAAa,EAAI,EAAIA,CACrD,CAIA,SAASC,EAAcC,EAAGC,EAAGC,EAAGC,EAAG,CAC/B,MAAO,QAAQR,EAAaK,CAAC,CAAC,KAAKL,EAAaM,CAAC,CAAC,KAAKN,EAAaO,CAAC,CAAC,KAAKL,EAAeM,CAAC,CAAC,GAChG,CACA,SAASC,EAAiBC,EAAIC,EAAIC,EAAIC,EAAIL,EAAG,CACzC,OAAOR,GAAcU,EAAKC,GAAM,EAAIE,GAAMD,EAAKC,GAAML,CAAC,CAC1D,CACO,SAASM,EAAUC,EAAYC,EAAS,CACtC,MAAM,QAAQD,CAAU,IACzBA,EAAajB,EAAKiB,CAAU,GAC3B,MAAM,QAAQC,CAAO,IACtBA,EAAUlB,EAAKkB,CAAO,GAC1B,MAAML,EAAKI,EAAW,CAAC,EACjBF,EAAKG,EAAQ,CAAC,EACdC,EAAQhB,EAAWU,EAAKE,EAAKF,EAAKE,CAAE,EAC1C,OAAOT,EAAcK,EAAiBM,EAAW,CAAC,EAAGJ,EAAIK,EAAQ,CAAC,EAAGH,EAAII,CAAK,EAAGR,EAAiBM,EAAW,CAAC,EAAGJ,EAAIK,EAAQ,CAAC,EAAGH,EAAII,CAAK,EAAGR,EAAiBM,EAAW,CAAC,EAAGJ,EAAIK,EAAQ,CAAC,EAAGH,EAAII,CAAK,EAAGA,CAAK,CAClN,CACO,SAASC,EAAYC,EAAMC,EAAS,CACvC,KAAM,CAACf,EAAGC,EAAGC,EAAGC,EAAI,CAAC,EAAI,MAAM,QAAQW,CAAI,EAAIA,EAAOrB,EAAKqB,CAAI,EAC/D,OAAIC,EAAQ,MACDhB,EAAcC,EAAGC,EAAGC,EAAGa,EAAQ,KAAK,EAExChB,EAAcC,EAAGC,EAAGC,EAAGC,CAAC,CACnC,CACO,SAASa,EAAWF,EAAMC,EAAS,CACtC,KAAM,CAACf,EAAGC,EAAGC,EAAGC,EAAI,CAAC,EAAI,MAAM,QAAQW,CAAI,EAAIA,EAAOrB,EAAKqB,CAAI,EACzD,CAAE,UAAAG,EAAY,EAAG,MAAAL,EAAQ,CAAC,EAAKG,EACrC,OAAOG,EAAa,CAAClB,EAAIiB,EAAWhB,EAAIgB,EAAWf,EAAIe,EAAWd,EAAIS,CAAK,CAAC,CAChF,CASO,SAAShB,EAAWnC,EAAO,CAC9B,MAAM0D,EAAI,KAAK,MAAM,OAAO1D,CAAK,EAAI,GAAG,EAAI,IAC5C,OAAI0D,EAAI,EACG,EACPA,EAAI,EACG,EACJA,CACX,CASO,SAASxB,EAAalC,EAAO,CAChC,MAAM0D,EAAI,KAAK,MAAM,OAAO1D,CAAK,CAAC,EAClC,OAAI0D,EAAI,IACG,IACPA,EAAI,EACG,EACJA,CACX,CAaO,SAASD,EAAaJ,EAAM,CAC/B,KAAM,CAACd,EAAGC,EAAGC,CAAC,EAAIY,EAClB,MAAI,MAAKA,EACE,QAAQnB,EAAaK,CAAC,CAAC,KAAKL,EAAaM,CAAC,CAAC,KAAKN,EAAaO,CAAC,CAAC,KAAKN,EAAWkB,EAAK,CAAC,CAAC,CAAC,IAE3F,QAAQnB,EAAaK,CAAC,CAAC,KAAKL,EAAaM,CAAC,CAAC,KAAKN,EAAaO,CAAC,CAAC,MAC1E,CCjNO,SAASkB,EAASC,EAAS,EAAG,CACjC,OAAO,KAAK,OAAQ,EACf,SAAS,EAAE,EACX,MAAM,EAAG,EAAIA,CAAM,CAC5B","x_google_ignoreList":[0,1,2,3,4,5,6,7]}