import{c as b}from"./@babel-BosuxZz1.js";var wn={};(function(o){var h=b&&b.__awaiter||function(n,t,e,r){return new(e||(e=Promise))(function(f,u){function s(a){try{m(r.next(a))}catch(l){u(l)}}function Sn(a){try{m(r.throw(a))}catch(l){u(l)}}function m(a){a.done?f(a.value):new e(function(l){l(a.value)}).then(s,Sn)}m((r=r.apply(n,t||[])).next())})};Object.defineProperty(o,"__esModule",{value:!0}),o.hashCodeInit=17;function p(n){let t=0;for(let e=0;e<n.length;e++){const r=n.charCodeAt(e);t=(t<<5)-t+r,t=t&t}return t}o.hashString=p;function d(n,t){return n*31+(t|0)|0}o.addHashCode=d;function M(n,t){return n!==void 0?n:t}o.withDefault=M;function v(n,t){if(n!==void 0)return t(n)}o.definedMap=v;function C(n,t,e){return M(v(n,e),t)}o.definedMapWithDefault=C;function E(n,t){return n==null?!1:Object.prototype.hasOwnProperty.call(n,t)}o.hasOwnProperty=E;function O(n,t){for(const e of n)if(t(e))return e}o.iterableFind=O;function B(n,t){for(const e of n)if(!t(e))return!1;return!0}o.iterableEvery=B;function _(n,t){for(const e of n)if(t(e))return!0;return!1}o.iterableSome=_;function U(n){for(const t of n)return t}o.iterableFirst=U;function q(n){let t;for(const e of n)(t===void 0||e>t)&&(t=e);return t}o.iterableMax=q;function P(n,t){let e,r;for(const f of n){const u=t(f);(e===void 0||u<e)&&(e=u,r=f)}return r}o.iterableMinBy=P;function R(n,t,e){let r=t;for(const f of n)r=e(r,f);return r}o.iterableReduce=R;function*T(n){let t=0;for(const e of n)yield[t,e],t+=1}o.iterableEnumerate=T;function*W(n,t){let e=0;for(const r of n)e>=t?yield r:e+=1}o.iterableSkip=W;function S(n,t){const e=n.length;if(!(t>e))return n[e-t]}o.arrayGetFromEnd=S;function j(n){return S(n,1)}o.arrayLast=j;function G(n){const t=n.length;if(t===0)throw new Error("Cannot pop empty array");return n.slice(0,t-1)}o.arrayPop=G;function z(n,t){const e=[];for(const r of t)e.length>0&&e.push(n),e.push(r);return e}o.arrayIntercalate=z;function D(n,t){return h(this,void 0,void 0,function*(){const e=[];let r=0;for(const f of n)e.push(yield t(f,r)),r+=1;return e})}o.arrayMapSync=D;function H(n,t){return n<t?-1:n>t?1:0}function y(n,t){return n.sort((e,r)=>H(t(e),t(r)))}o.arraySortByInto=y;function K(n){return Array.isArray(n)?n:Array.from(n)}o.toReadonlyArray=K;function L(n,t){const e=new Map;for(const[r,f]of n)e.set(r,t(f,r));return e}o.mapMap=L;function N(n){for(const t of n.values())return t}o.mapFirst=N;function V(n,t){for(const e of n.values())if(e===t)return!0;return!1}o.mapContains=V;function $(n,t){for(const[e,r]of n)if(t(r,e))return!0;return!1}o.mapSome=$;function w(n,t){for(const[e,r]of t)n.set(e,r);return n}o.mapMergeInto=w;function J(n,t){const e=new Map(n);return w(e,t),e}o.mapMerge=J;function g(n,t,e){for(const[r,f]of e){const u=n.get(r),s=u===void 0?f:t(u,f,r);n.set(r,s)}return n}o.mapMergeWithInto=g;function Q(n,t,e){const r=new Map(n);return g(r,t,e),r}o.mapMergeWith=Q;function X(n,t){const e=new Map;for(const[r,f]of n)t(f,r)&&e.set(r,f);return e}o.mapFilter=X;function Y(n,t){const e=new Map;for(const[r,f]of n){const u=t(f,r);u!==void 0&&e.set(r,u)}return e}o.mapFilterMap=Y;function I(n,t){return y(Array.from(n),([e,r])=>t(r,e))}o.mapSortToArray=I;function F(n,t){return new Map(I(n,t))}o.mapSortBy=F;function Z(n){return F(n,(t,e)=>e)}o.mapSortByKey=Z;function x(n,t){const e=new Map;for(const[r,f]of n){const[u,s]=t(f,r);e.set(u,s)}return e}o.mapMapEntries=x;function nn(n,t,e){return n.set(t,e(n.get(t))),n}o.mapUpdateInto=nn;function tn(n){const t=new Map;for(const e of Object.getOwnPropertyNames(n))t.set(e,n[e]);return t}o.mapFromObject=tn;function en(n){const t={};for(const[e,r]of n)t[e]=r;return t}o.mapToObject=en;function rn(n,t){const e=new Map;for(const r of n)e.set(r,t(r));return e}o.mapFromIterable=rn;function on(n,t){for(const[e,r]of n)if(t(r,e))return r}o.mapFind=on;function fn(n){const t=new Map;for(const e of n)for(const[r,f]of e){let u=t.get(r);u===void 0&&(u=[],t.set(r,u)),u.push(f)}return t}o.mapTranspose=fn;function un(n,t){return h(this,void 0,void 0,function*(){const e=new Map;for(const[r,f]of n)e.set(r,yield t(f,r));return e})}o.mapMapSync=un;function an(n,t){for(const e of t)if(!n.has(e))return!1;return!0}o.setIsSuperset=an;function k(n,t){for(const e of t)for(const r of e)n.add(r);return n}o.setUnionManyInto=k;function A(n,...t){return k(n,t)}o.setUnionInto=A;function cn(n,t){const e=new Set;for(const r of n)t.has(r)&&e.add(r);return e}o.setIntersect=cn;function sn(n,t){const e=new Set(n);for(const r of t)e.delete(r);return e}o.setSubtract=sn;function ln(...n){const t=new Set;return A(t,...n),t}o.setUnion=ln;function dn(n,t){const e=new Set;for(const r of n)e.add(t(r));return e}o.setMap=dn;function yn(n,t){const e=new Set;for(const r of n)t(r)&&e.add(r);return e}o.setFilter=yn;function mn(n,t){const e=new Set;for(const r of n){const f=t(r);f!==void 0&&e.add(f)}return e}o.setFilterMap=mn;function hn(n,t){return new Set(y(Array.from(n),t))}o.setSortBy=hn;function pn(n,t){const e=new Map;for(const r of n){const f=t(r);let u=e.get(f);u===void 0&&(u=new Set,e.set(f,u)),u.add(r)}return e}o.setGroupBy=pn;function Mn(n){return n instanceof Set?n:new Set(n)}o.toReadonlySet=Mn;class vn{constructor(){this._map=new Map}set(t,e){let r=i(t)|0;for(;;){const f=this._map.get(r);if(f===void 0){this._map.set(r,[t,e]);return}if(c(t,f[0])){f[1]=e;return}r=r+1|0}}get(t){let e=i(t)|0;for(;;){const r=this._map.get(e);if(r===void 0)return;if(c(t,r[0]))return r[1];e=e+1|0}}has(t){return this.get(t)!==void 0}*values(){for(const[,[,t]]of this._map)yield t}}o.EqualityMap=vn;function c(n,t){if(n===t)return!0;if(n===void 0||t===void 0||n===null||t===null)return!1;if(typeof n.equals=="function"&&typeof t.equals=="function")return n.equals(t);if(n instanceof Set&&t instanceof Set){if(n.size!==t.size)return!1;for(const e of n)if(!t.has(e))return!1;return!0}if(n instanceof Map&&t instanceof Map){if(n.size!==t.size)return!1;for(const[e,r]of n){const f=t.get(e);if(!c(r,f))return!1}return!0}if(Array.isArray(n)&&Array.isArray(t)){const e=n.length;if(e!==t.length)return!1;for(let r=0;r<e;r++)if(!c(n[r],t[r]))return!1;return!0}return!1}o.areEqual=c;function i(n){if(typeof n=="number")return n|0;if(typeof n=="string")return p(n);let t=o.hashCodeInit;if(n===void 0)return t;if(n===!0)return t+1|0;if(n===!1)return t+2|0;if(n===null)return t+3|0;if(typeof n.hashCode=="function")return n.hashCode();if(n instanceof Set){for(const e of n)t+=i(e);return t}if(n instanceof Map){let e=o.hashCodeInit;for(const[r,f]of n)e+=i(r),t+=i(f);return d(e,t)}if(Array.isArray(n)){for(const e of n)t=d(t,i(e));return t}throw new Error(`Cannot hash ${n}`)}o.hashCodeOf=i})(wn);export{wn as d};
