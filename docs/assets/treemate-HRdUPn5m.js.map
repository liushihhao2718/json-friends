{"version":3,"file":"treemate-HRdUPn5m.js","sources":["../../node_modules/treemate/es/utils.js","../../node_modules/treemate/es/check.js","../../node_modules/treemate/es/path.js","../../node_modules/treemate/es/move.js","../../node_modules/treemate/es/flatten.js","../../node_modules/treemate/es/contains.js","../../node_modules/treemate/es/create.js"],"sourcesContent":["export function toArray(arg) {\n    if (Array.isArray(arg))\n        return arg;\n    return [arg];\n}\n// Do not use enum for lint plugin has error\nexport const TRAVERSE_COMMAND = {\n    STOP: 'STOP'\n};\nexport function traverseWithCb(treeNode, callback) {\n    const command = callback(treeNode);\n    if (treeNode.children !== undefined && command !== TRAVERSE_COMMAND.STOP) {\n        treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));\n    }\n}\nexport function getNonLeafKeys(treeNodes, options = {}) {\n    const { preserveGroup = false } = options;\n    const keys = [];\n    const cb = preserveGroup\n        ? (node) => {\n            if (!node.isLeaf) {\n                keys.push(node.key);\n                traverse(node.children);\n            }\n        }\n        : (node) => {\n            if (!node.isLeaf) {\n                if (!node.isGroup)\n                    keys.push(node.key);\n                traverse(node.children);\n            }\n        };\n    function traverse(nodes) {\n        nodes.forEach(cb);\n    }\n    traverse(treeNodes);\n    return keys;\n}\nexport function isLeaf(rawNode, getChildren) {\n    const { isLeaf } = rawNode;\n    if (isLeaf !== undefined)\n        return isLeaf;\n    else if (!getChildren(rawNode))\n        return true;\n    return false;\n}\nexport function defaultGetChildren(node) {\n    return node.children;\n}\nexport function defaultGetKey(node) {\n    return node.key;\n}\nexport function isIgnored() {\n    return false;\n}\nexport function isShallowLoaded(rawNode, getChildren) {\n    const { isLeaf } = rawNode;\n    if (isLeaf === false && !Array.isArray(getChildren(rawNode)))\n        return false;\n    return true;\n}\nexport function isDisabled(rawNode) {\n    return rawNode.disabled === true;\n}\nexport function isExpilicitlyNotLoaded(rawNode, getChildren) {\n    return (rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode)));\n}\nexport function isNodeInvalid(rawNode, getChildren) {\n    if (rawNode.isLeaf === true) {\n        const children = getChildren(rawNode);\n        if (Array.isArray(children) && children.length > 0)\n            return true;\n    }\n    return false;\n}\nexport function unwrapCheckedKeys(result) {\n    var _a;\n    if (result === undefined || result === null)\n        return [];\n    if (Array.isArray(result))\n        return result;\n    return (_a = result.checkedKeys) !== null && _a !== void 0 ? _a : [];\n}\nexport function unwrapIndeterminateKeys(result) {\n    var _a;\n    if (result === undefined || result === null || Array.isArray(result)) {\n        return [];\n    }\n    return (_a = result.indeterminateKeys) !== null && _a !== void 0 ? _a : [];\n}\nexport function merge(originalKeys, keysToAdd) {\n    const set = new Set(originalKeys);\n    keysToAdd.forEach((key) => {\n        if (!set.has(key)) {\n            set.add(key);\n        }\n    });\n    return Array.from(set);\n}\nexport function minus(originalKeys, keysToRemove) {\n    const set = new Set(originalKeys);\n    keysToRemove.forEach((key) => {\n        if (set.has(key)) {\n            set.delete(key);\n        }\n    });\n    return Array.from(set);\n}\nexport function isGroup(rawNode) {\n    return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === 'group';\n}\nexport function createIndexGetter(treeNodes) {\n    const map = new Map();\n    treeNodes.forEach((treeNode, i) => {\n        map.set(treeNode.key, i);\n    });\n    return (key) => { var _a; return (_a = map.get(key)) !== null && _a !== void 0 ? _a : null; };\n}\n","import { isExpilicitlyNotLoaded, merge, minus, traverseWithCb, TRAVERSE_COMMAND } from './utils';\nexport class SubtreeNotLoadedError extends Error {\n    constructor() {\n        super();\n        this.message =\n            'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';\n    }\n}\nfunction getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);\n}\nfunction getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {\n    const visitedKeys = new Set();\n    uncheckedKeys.forEach((uncheckedKey) => {\n        const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);\n        if (uncheckedTreeNode !== undefined) {\n            let nodeCursor = uncheckedTreeNode.parent;\n            while (nodeCursor !== null) {\n                if (nodeCursor.disabled)\n                    break;\n                if (visitedKeys.has(nodeCursor.key))\n                    break;\n                else {\n                    visitedKeys.add(nodeCursor.key);\n                }\n                nodeCursor = nodeCursor.parent;\n            }\n        }\n    });\n    return visitedKeys;\n}\nfunction getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {\n    const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);\n    const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);\n    const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);\n    const keysToRemove = [];\n    extendedCheckedKeySet.forEach((key) => {\n        if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {\n            keysToRemove.push(key);\n        }\n    });\n    keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));\n    return extendedCheckedKeySet;\n}\nexport function getCheckedKeys(options, treeMate) {\n    const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;\n    if (!cascade) {\n        if (keysToCheck !== undefined) {\n            return {\n                checkedKeys: merge(checkedKeys, keysToCheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else if (keysToUncheck !== undefined) {\n            return {\n                checkedKeys: minus(checkedKeys, keysToUncheck),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n        else {\n            return {\n                checkedKeys: Array.from(checkedKeys),\n                indeterminateKeys: Array.from(indeterminateKeys)\n            };\n        }\n    }\n    const { levelTreeNodeMap } = treeMate;\n    let extendedCheckedKeySet;\n    if (keysToUncheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else if (keysToCheck !== undefined) {\n        extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);\n    }\n    else {\n        extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);\n    }\n    const checkStrategyIsParent = checkStrategy === 'parent';\n    const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;\n    const syntheticCheckedKeySet = extendedCheckedKeySet;\n    const syntheticIndeterminateKeySet = new Set();\n    const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));\n    // cascade check\n    // 1. if tree is fully loaded, it just works\n    // 2. if the tree is not fully loaded, we assume that keys which is in not\n    //    loaded tree are not in checked keys\n    //    for example:\n    //    a -- b(fully-loaded)   -- c(fully-loaded)\n    //      |- d(partial-loaded) -- ?e(not-loaded)\n    //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s\n    //    and `a`'s status\n    for (let level = maxLevel; level >= 0; level -= 1) {\n        const levelIsZero = level === 0;\n        // it should exists, nor it is a bug\n        const levelTreeNodes = levelTreeNodeMap.get(level);\n        for (const levelTreeNode of levelTreeNodes) {\n            if (levelTreeNode.isLeaf)\n                continue;\n            const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;\n            if (checkStrategyIsChild && shallowLoaded) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                levelTreeNode.children.forEach((v) => {\n                    if (!v.disabled &&\n                        !v.isLeaf &&\n                        v.shallowLoaded &&\n                        syntheticCheckedKeySet.has(v.key)) {\n                        syntheticCheckedKeySet.delete(v.key);\n                    }\n                });\n            }\n            if (levelTreeNode.disabled || !shallowLoaded) {\n                continue;\n            }\n            let fullyChecked = true;\n            let partialChecked = false;\n            let allDisabled = true;\n            // it is shallow loaded, so `children` must exist\n            for (const childNode of levelTreeNode.children) {\n                const childKey = childNode.key;\n                if (childNode.disabled)\n                    continue;\n                if (allDisabled)\n                    allDisabled = false;\n                if (syntheticCheckedKeySet.has(childKey)) {\n                    partialChecked = true;\n                }\n                else if (syntheticIndeterminateKeySet.has(childKey)) {\n                    partialChecked = true;\n                    fullyChecked = false;\n                    break;\n                }\n                else {\n                    fullyChecked = false;\n                    if (partialChecked) {\n                        break;\n                    }\n                }\n            }\n            if (fullyChecked && !allDisabled) {\n                if (checkStrategyIsParent) {\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    levelTreeNode.children.forEach((v) => {\n                        if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {\n                            syntheticCheckedKeySet.delete(v.key);\n                        }\n                    });\n                }\n                syntheticCheckedKeySet.add(levelTreeNodeKey);\n            }\n            else if (partialChecked) {\n                syntheticIndeterminateKeySet.add(levelTreeNodeKey);\n            }\n            if (levelIsZero &&\n                checkStrategyIsChild &&\n                syntheticCheckedKeySet.has(levelTreeNodeKey)) {\n                syntheticCheckedKeySet.delete(levelTreeNodeKey);\n            }\n        }\n    }\n    return {\n        checkedKeys: Array.from(syntheticCheckedKeySet),\n        indeterminateKeys: Array.from(syntheticIndeterminateKeySet)\n    };\n}\n// unchecking is safe when doing cascade uncheck in async mode\nexport function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {\n    const { treeNodeMap, getChildren } = treeMate;\n    const visitedKeySet = new Set();\n    const extendedKeySet = new Set(checkedKeys);\n    checkedKeys.forEach((checkedKey) => {\n        const checkedTreeNode = treeNodeMap.get(checkedKey);\n        if (checkedTreeNode !== undefined) {\n            traverseWithCb(checkedTreeNode, (treeNode) => {\n                if (treeNode.disabled) {\n                    return TRAVERSE_COMMAND.STOP;\n                }\n                const { key } = treeNode;\n                if (visitedKeySet.has(key))\n                    return;\n                visitedKeySet.add(key);\n                // Adding keys before loaded check is okay, since if not valid error\n                // would be thrown\n                extendedKeySet.add(key);\n                if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {\n                    if (isUnchecking) {\n                        return TRAVERSE_COMMAND.STOP;\n                    }\n                    else if (!allowNotLoaded) {\n                        throw new SubtreeNotLoadedError();\n                    }\n                }\n            });\n        }\n    });\n    return extendedKeySet;\n}\n","export function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {\n    var _a;\n    const treeNodeMap = treeMate.treeNodeMap;\n    let treeNode = key === null || key === undefined ? null : (_a = treeNodeMap.get(key)) !== null && _a !== void 0 ? _a : null;\n    const mergedPath = {\n        keyPath: [],\n        treeNodePath: [],\n        treeNode: treeNode\n    };\n    if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {\n        mergedPath.treeNode = null;\n        return mergedPath;\n    }\n    while (treeNode) {\n        if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {\n            mergedPath.treeNodePath.push(treeNode);\n        }\n        treeNode = treeNode.parent;\n    }\n    mergedPath.treeNodePath.reverse();\n    if (!includeSelf)\n        mergedPath.treeNodePath.pop();\n    mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode) => treeNode.key);\n    return mergedPath;\n}\n","export function getFirstAvailableNode(nodes) {\n    if (nodes.length === 0)\n        return null;\n    const node = nodes[0];\n    if (node.isGroup || node.ignored || node.disabled) {\n        return node.getNext();\n    }\n    return node;\n}\nfunction rawGetNext(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index + 1) % l];\n    }\n    else {\n        if (index === sibs.length - 1)\n            return null;\n        return sibs[index + 1];\n    }\n}\nfunction move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {\n    const iterate = dir === 'prev' ? rawGetPrev : rawGetNext;\n    const getChildOptions = {\n        reverse: dir === 'prev'\n    };\n    let meet = false;\n    let endNode = null;\n    function traverse(node) {\n        if (node === null)\n            return;\n        if (node === fromNode) {\n            if (!meet) {\n                meet = true;\n            }\n            else if (!fromNode.disabled && !fromNode.isGroup) {\n                endNode = fromNode;\n                return;\n            }\n        }\n        else {\n            if ((!node.disabled || includeDisabled) &&\n                !node.ignored &&\n                !node.isGroup) {\n                endNode = node;\n                return;\n            }\n        }\n        if (node.isGroup) {\n            const child = getChild(node, getChildOptions);\n            if (child !== null) {\n                endNode = child;\n            }\n            else {\n                traverse(iterate(node, loop));\n            }\n        }\n        else {\n            const nextNode = iterate(node, false);\n            if (nextNode !== null) {\n                traverse(nextNode);\n            }\n            else {\n                const parent = rawGetParent(node);\n                if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n                    traverse(iterate(parent, loop));\n                }\n                else if (loop) {\n                    traverse(iterate(node, true));\n                }\n            }\n        }\n    }\n    traverse(fromNode);\n    return endNode;\n}\nfunction rawGetPrev(node, loop) {\n    const sibs = node.siblings;\n    const l = sibs.length;\n    const { index } = node;\n    if (loop) {\n        return sibs[(index - 1 + l) % l];\n    }\n    else {\n        if (index === 0)\n            return null;\n        return sibs[index - 1];\n    }\n}\nfunction rawGetParent(node) {\n    return node.parent;\n}\nfunction getChild(node, options = {}) {\n    const { reverse = false } = options;\n    const { children } = node;\n    if (children) {\n        const { length } = children;\n        const start = reverse ? length - 1 : 0;\n        const end = reverse ? -1 : length;\n        const delta = reverse ? -1 : 1;\n        for (let i = start; i !== end; i += delta) {\n            const child = children[i];\n            if (!child.disabled && !child.ignored) {\n                if (child.isGroup) {\n                    const childInGroup = getChild(child, options);\n                    if (childInGroup !== null)\n                        return childInGroup;\n                }\n                else {\n                    return child;\n                }\n            }\n        }\n    }\n    return null;\n}\nexport const moveMethods = {\n    getChild() {\n        if (this.ignored)\n            return null;\n        return getChild(this);\n    },\n    getParent() {\n        const { parent } = this;\n        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {\n            return parent.getParent();\n        }\n        return parent;\n    },\n    getNext(options = {}) {\n        return move(this, 'next', options);\n    },\n    getPrev(options = {}) {\n        return move(this, 'prev', options);\n    }\n};\n","export function flatten(treeNodes, expandedKeys) {\n    const expandedKeySet = expandedKeys ? new Set(expandedKeys) : undefined;\n    const flattenedNodes = [];\n    function traverse(treeNodes) {\n        treeNodes.forEach((treeNode) => {\n            flattenedNodes.push(treeNode);\n            if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)\n                return;\n            if (treeNode.isGroup) {\n                // group node shouldn't be expanded\n                traverse(treeNode.children);\n            }\n            else if (\n            // normal non-leaf node\n            expandedKeySet === undefined ||\n                expandedKeySet.has(treeNode.key)) {\n                traverse(treeNode.children);\n            }\n        });\n    }\n    traverse(treeNodes);\n    return flattenedNodes;\n}\n","export function contains(parent, child) {\n    const parentKey = parent.key;\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (child) {\n        if (child.key === parentKey)\n            return true;\n        child = child.parent;\n    }\n    return false;\n}\n","import { getCheckedKeys } from './check';\nimport { toArray, isDisabled, isLeaf, isGroup, isNodeInvalid, unwrapCheckedKeys, isShallowLoaded, unwrapIndeterminateKeys, getNonLeafKeys, isIgnored, defaultGetChildren, defaultGetKey } from './utils';\nimport { getPath } from './path';\nimport { moveMethods, getFirstAvailableNode } from './move';\nimport { flatten } from './flatten';\nimport { contains } from './contains';\nfunction createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {\n    const treeNodes = [];\n    rawNodes.forEach((rawNode, index) => {\n        var _a;\n        if (process.env.NODE_ENV !== 'production' &&\n            isNodeInvalid(rawNode, getChildren)) {\n            console.error('[treemate]: node', rawNode, 'is invalid');\n        }\n        const treeNode = Object.create(nodeProto);\n        treeNode.rawNode = rawNode;\n        treeNode.siblings = treeNodes;\n        treeNode.level = level;\n        treeNode.index = index;\n        treeNode.isFirstChild = index === 0;\n        treeNode.isLastChild = index + 1 === rawNodes.length;\n        treeNode.parent = parent;\n        if (!treeNode.ignored) {\n            const rawChildren = getChildren(rawNode);\n            if (Array.isArray(rawChildren)) {\n                treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);\n            }\n        }\n        treeNodes.push(treeNode);\n        treeNodeMap.set(treeNode.key, treeNode);\n        if (!levelTreeNodeMap.has(level))\n            levelTreeNodeMap.set(level, []);\n        (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);\n    });\n    return treeNodes;\n}\nexport function createTreeMate(rawNodes, options = {}) {\n    var _a;\n    const treeNodeMap = new Map();\n    const levelTreeNodeMap = new Map();\n    const { getDisabled = isDisabled, getIgnored = isIgnored, getIsGroup = isGroup, getKey = defaultGetKey } = options;\n    const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;\n    const getChildren = options.ignoreEmptyChildren\n        ? (node) => {\n            const children = _getChildren(node);\n            if (Array.isArray(children)) {\n                if (!children.length)\n                    return null;\n                return children;\n            }\n            return children;\n        }\n        : _getChildren;\n    const nodeProto = Object.assign({\n        get key() {\n            // do not pass parent or related things to it\n            // the key need to be specified explicitly\n            return getKey(this.rawNode);\n        },\n        get disabled() {\n            return getDisabled(this.rawNode);\n        },\n        get isGroup() {\n            return getIsGroup(this.rawNode);\n        },\n        get isLeaf() {\n            return isLeaf(this.rawNode, getChildren);\n        },\n        get shallowLoaded() {\n            return isShallowLoaded(this.rawNode, getChildren);\n        },\n        get ignored() {\n            return getIgnored(this.rawNode);\n        },\n        contains(node) {\n            return contains(this, node);\n        }\n    }, moveMethods);\n    const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);\n    function getNode(key) {\n        if (key === null || key === undefined)\n            return null;\n        const tmNode = treeNodeMap.get(key);\n        if (tmNode && !tmNode.isGroup && !tmNode.ignored) {\n            return tmNode;\n        }\n        return null;\n    }\n    function _getNode(key) {\n        if (key === null || key === undefined)\n            return null;\n        const tmNode = treeNodeMap.get(key);\n        if (tmNode && !tmNode.ignored) {\n            return tmNode;\n        }\n        return null;\n    }\n    function getPrev(key, options) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getPrev(options);\n    }\n    function getNext(key, options) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getNext(options);\n    }\n    function getParent(key) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getParent();\n    }\n    function getChild(key) {\n        const node = _getNode(key);\n        if (!node)\n            return null;\n        return node.getChild();\n    }\n    const treemate = {\n        treeNodes,\n        treeNodeMap,\n        levelTreeNodeMap,\n        maxLevel: Math.max(...levelTreeNodeMap.keys()),\n        getChildren,\n        getFlattenedNodes(expandedKeys) {\n            return flatten(treeNodes, expandedKeys);\n        },\n        getNode,\n        getPrev,\n        getNext,\n        getParent,\n        getChild,\n        getFirstAvailableNode() {\n            return getFirstAvailableNode(treeNodes);\n        },\n        getPath(key, options = {}) {\n            return getPath(key, options, treemate);\n        },\n        getCheckedKeys(checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        check(keysToCheck, checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                keysToCheck: keysToCheck === undefined || keysToCheck === null\n                    ? []\n                    : toArray(keysToCheck),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        uncheck(keysToUncheck, checkedKeys, options = {}) {\n            const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;\n            return getCheckedKeys({\n                checkedKeys: unwrapCheckedKeys(checkedKeys),\n                indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),\n                keysToUncheck: keysToUncheck === null || keysToUncheck === undefined\n                    ? []\n                    : toArray(keysToUncheck),\n                cascade,\n                leafOnly,\n                checkStrategy,\n                allowNotLoaded\n            }, treemate);\n        },\n        getNonLeafKeys(options = {}) {\n            return getNonLeafKeys(treeNodes, options);\n        }\n    };\n    return treemate;\n}\n"],"names":["toArray","arg","TRAVERSE_COMMAND","traverseWithCb","treeNode","callback","command","childNode","getNonLeafKeys","treeNodes","options","preserveGroup","keys","cb","node","traverse","nodes","isLeaf","rawNode","getChildren","defaultGetChildren","defaultGetKey","isIgnored","isShallowLoaded","isDisabled","isExpilicitlyNotLoaded","unwrapCheckedKeys","result","_a","unwrapIndeterminateKeys","merge","originalKeys","keysToAdd","set","key","minus","keysToRemove","isGroup","createIndexGetter","map","i","SubtreeNotLoadedError","getExtendedCheckedKeySetAfterCheck","checkKeys","currentCheckedKeys","treeMate","allowNotLoaded","getExtendedCheckedKeySet","getAvailableAscendantNodeSet","uncheckedKeys","visitedKeys","uncheckedKey","uncheckedTreeNode","nodeCursor","getExtendedCheckedKeySetAfterUncheck","extendedCheckedKeySet","extendedKeySetToUncheck","ascendantKeySet","getCheckedKeys","checkedKeys","keysToCheck","keysToUncheck","indeterminateKeys","cascade","leafOnly","checkStrategy","levelTreeNodeMap","checkStrategyIsParent","checkStrategyIsChild","syntheticCheckedKeySet","syntheticIndeterminateKeySet","maxLevel","level","levelIsZero","levelTreeNodes","levelTreeNode","levelTreeNodeKey","shallowLoaded","v","fullyChecked","partialChecked","allDisabled","childKey","isUnchecking","treeNodeMap","visitedKeySet","extendedKeySet","checkedKey","checkedTreeNode","getPath","includeGroup","includeSelf","mergedPath","getFirstAvailableNode","rawGetNext","loop","sibs","l","index","move","fromNode","dir","includeDisabled","iterate","rawGetPrev","getChildOptions","meet","endNode","child","getChild","nextNode","parent","rawGetParent","reverse","children","length","start","end","delta","childInGroup","moveMethods","flatten","expandedKeys","expandedKeySet","flattenedNodes","contains","parentKey","createTreeNodes","rawNodes","nodeProto","rawChildren","createTreeMate","getDisabled","getIgnored","getIsGroup","getKey","_getChildren","getNode","tmNode","_getNode","getPrev","getNext","getParent","treemate"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6]}